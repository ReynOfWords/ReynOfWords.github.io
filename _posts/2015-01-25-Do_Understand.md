---
layout: post
title: Do, then understand.
---

After taking a quick look at my current goals, or I guess I should say goal, of learning to program, I realized that while it's an admirable target, it is also a forever moving one.

I don't get on particularly well with never-ending goals.

It's not that such a goal is wrong, per se; more that it gives me no good mile markers for saying, "I know more now than I did then." I'm trying to grasp the reality of trying to learn something, whether it be the programming field or a game that continuously changes, where there is no set endpoint. That lack of endpoint is one of the attractive things about those kinds of skills. Being able to always learn new things makes it much more difficult to get bored.

Unfortunately, it does make it easier to get overwhelmed. It also means that there are large variety of ways into the activity, which makes it very difficult to know where to start. Or which starting places will be effective.

So I've decided to start by doing. I may not know exactly what I'll end up with, but I know I'll end up with something. I started on this road because I wanted to change one of the pieces of software that I use regularly in my day job to better fit my needs, so I'm going to use that as my first end goal.

All the psychology and self help that I've read say that it's easiest to reach a goal if you create small, easily managed goals that lead up to it. Since the programs that I need to write, or rewrite as the case may be, is written in Ruby, I've picked up a copy of the Zed Shaw's book [_Learn Ruby the Hard Way_](http://learncodethehardway.org/ruby/). Each chapter is a single exercise which it looks like I can do in an hour or so each day, and I think everything I need to know will be covered in that book. At least enough so I'll know where to look if I get stuck when building my own program.

Until next week.